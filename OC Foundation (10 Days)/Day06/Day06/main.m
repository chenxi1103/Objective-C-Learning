//
//  main.m
//  Day06
//
//  Created by Li, Chenxi on 3/24/21.
//  Copyright © 2021 Li, Chenxi. All rights reserved.
//
/**
 Day07 - 内存管理
 1. 内存管理
    内存的作用：存储数据
    a 如何将数据存储到内存之中
        声明一个变量，然后将这个数据存储进去
    b 当数据不再被使用的时候，占用的内存空间如何被释放
        内存中的五大区域：
            栈：局部变量，当局部变量的作用域被执行完毕后，局部变量就会被系统立即回收。（系统自动完成）
            堆：OC对象，使用c函数申请的动态空间
            BSS段：未初始化的全局变量，静态变量。一旦初始化，就回收，并转存在数据段 （系统自动完成）
            数据段：已经初始化的全局变量和静态变量，直到程序结束才会被回收（系统自动完成）
            代码段：代码，程序结束的时候系统才会自动回收代码段中的数据（系统自动完成）
    c 栈，bss段，数据段，代码段的数据回收由系统自动完成，不需要我们干预
     但是分配在堆区中的oc对象是肯定需要回收的。
    【iphone 内存机制】如果内存占用超过40m就会发出警告。45m再次发出警告，120m直接闪退。
    d 如何回收堆中的oc对象？
        存储在堆中的oc对象系统不会自动回收，直到程序结束才会被回收。如果我们在程序结束前就回收，我们需要自己来回收堆中的oc对象。
        我们只需要管理存储在堆中oc对象的回收。
        oc对象应该什么时候回收？用完就回收（没有任何人使用的情况下）！
    e 如何知道有没有在用这个对象了呢：引入计数器
        每个对象都有一个属性叫做retainCount，叫做引用计数器，类型是unsigned long （8个字节）
        作用：用来记录目前有多少人在使用该对象。（默认值是1）
        操作：当多一个人使用该对象时，应该先让这个对象的引用计数器的值+1，代表这个对象多一个人使用
             当这个对象少一个人使用的时候，应该先让这个对象的引用计数器的值-1。
             当引用计数器变为0的时候，代表这个对象无人使用，这个时候系统就会自动回收这个对象了。
        具体操作：
            1 为对象放一条retain消息，对象的引用计数器就会+1
            2 为对象放松一条release消息，对象的引用计数器就会-1。
            3 为对象发送一条retainCount消息，就可以得到对象引入计数器的值
            4 ++-- 当对象引用计数器变为0的时候，对象就会被系统立即回收，在对象被回收时，会自动调用对象的dealloc的方法。
 
 2. 内存管理的分类
    MRC: Manual Reference Counting 手动引用计数，手动内存管理
        即当多一个人使用对象，要求程序员手动发送retain消息，少一个要手动发送release消息
    ARC: Automatic Reference Counting 自动引用计数，自动内存管理
        系统自动在合适的地方发送retain release消息。
 
    学习MRC的理由：
        a 面试必考 100%
        b 在2011年ios5之前，没有arc的存在，早期的app开发都用的是mrc技术。
        c ios大牛都是从mrc成长起来的（比arc更精确）
        d arc是基于mrc的，如果想搞明白arc的底层原理，mrc必须搞懂。
 
 3. MRC
    a 目前的xcode是默认支持arc开发，默认开发方式是arc，需要关闭arc开启mrc。
    b 实例见MRC target
 
 4. 内存管理的重点
    a 什么时候为对象发送retain消息
    b 什么时候为对象发送release消息
 
 5. 内存管理的原则
    a  arc机制下，retain，release，dealloc这些方法都无法调用
    b 有对象的创建，就要匹配一个release
    c retain的次数和release的次数要匹配。
    d 谁用谁retain，谁不用谁release，有始有终有加有减，一定要平衡。
 
 6. 野指针和僵尸变量：
    a 在c语言中的野指针：定义一个指针变量却没有初始化。
    b 在oc中的野指针：指针指向的对象已经被回收了。
    c 🧟‍♀️ 僵尸对象：
        申请一个变量，实际上是向系统申请指定字节数的空间，这些空间系统就不会再分配给别人了，当变量被回收的时候，代表变量占用的字节空间从此以后系统可以分配给别人使用。但是字节空间中存储的数据还在，当对象占用的空间没有分配给别人之前，其实对象数据还在，我还是能访问这个数据，调用对象方法。这个对象就叫做僵尸对象。
    d 当我们用野指针访问僵尸对象时，有可能有问题，也有可能没问题，当且仅当僵尸对象占用的空间没有分配给别人使用的时候，野指针就还能访问此僵尸对象，如果已经分配给别人，就会报错。
    e 但我们认为，只要一个对象成为了僵尸对象，无论如何都不该允许访问了。所以希望如果访问的是僵尸对象，无论如何报错。 -> 僵尸对象的实时检查机制，可将此机制打开，打开后，只要访问的是僵尸对象，无论空间是否分配都会报错。
    f 为什么不default打开僵尸对象检测呢？
        因为一旦打开检测，每访问一个对象的时候，都会先检查这个对象是不是一个僵尸对象，及其消耗性能。所以做测试的时候可以打开，平时一般不打开。
    g. 如何不打开僵尸对象检测且避免僵尸对象错误：当一个指针变成野指针后，将这个指针的值指向nil。当一个指针为nil时，通过这个指针调用对象的方法时（包括点语法），不会报错，也不会有任何反应。但是如果通过指针直接访问属性就会报错。
    h. 无法复活一个僵尸对象！！！（不要在release了对象以后再retain）
 
 7. 内存泄漏
    指的是一个对象没有被及时回收，在该回收的时候没有回收，一直驻留在内存中，直到程序结束才回收
    单个对象的内存泄漏情况：
        1 有对象的创建，没有对应的release
        2 retain次数和release次数不匹配
        3 在不适当的时候，为指针赋值为nil
        4 在方法中为传入的对象进行不适当的retain
    如果保证单个对象可以被回收
        1 有对象的创建就要匹配一个release
        2 retain的次数和release次数要匹配
        3 只有指针为野指针的时候才赋值为nil
        4 在方法中不要随意为传入的对象retain
    当为对象的属性多次赋值的时候，如果不release旧对象，就会发生内存泄漏，应该release旧的，retain新的。
    当为对象属性多次赋值的时候，如果新旧对象是同一个对象，还release的话，就会出现内存泄漏。当发现新旧对象是一个对象的时候，什么都不用做。当新旧对象不是一个对象时才release旧的retain新的
 
 8 完美版的setter写法：
    -(void)setCar:(Car *)car
    {
        if (_car != car) //说明新旧对象不是一个对象
        {
            [_car release];
            [car retain];
        }
        _car = car;
    }
     - (void) dealloc
     {
         NSLog(@"人死掉了。。。");
         //因为人死掉了，所以意味着少一个人使用他所拥有的车了,所以要为这个车发送release消息。
         [_car release];
         [super dealloc];
     }
 
 9 注意：我们管理的范围是oc对象，只有属性的类型是oc对象的时候，setter的方法才应该像上面这样写，如果不是oc对象（基本数据类型）直接赋值即可。
 
 10. 在MRC开发模式下，1个类的属性如果是1个oc对象类型的，那么这个属性的setter方法就应该按照上面的格式写（还要重写dealloc方法）如果属性类型不是oc对象类型，什么也不用做。
 
 11 @property
    作用：
        a 自动生成私有属性
        b 自动生成这个属性的getter setter方法声明
        c 自动生成这个属性的getter setter方法的实现
        在生成的setter方法的实现中，无论是什么类型的都直接赋值。
    带参数的property
        a @property(参数1，参数2，参数3。。。）数据类型 名称；
        b @property的四组参数
            1 与多线程相关的两个参数：atomic / nonatomic（默认atomic）
                atomic：会把生成的setter方法加线程安全锁->线程安全but效率较低
                nonatomic：无线程安全锁，不安全但效率高，建议选择nonatomic来提高效率。
 
            2 与生成的setter方法的实现相关的参数：assign，retain（默认assign）
                assign：生成的setter方法实现就是直接赋值
                retain：生成的setter方法的实现就是标准的mrc内存管理代码（先判断新旧对象是否为同一对象，如果不是就release旧的retain新的）。
                建议：如果属性类型是oc对象，就用retain！如果不是就默认assign。
                千万注意：retain参数只是生成标准的setter方法为标准的mrc内存管理代码，不会自动在dealloc中release，我们还是要自己手动在dealloc中release。
 
            3 与生成只读，读写相关的参数：readonly，readwrite（默认readwrite）
                readwrite：同时生成getter，setter。
                readonly：只生成getter。
            4 与生成getter，setter方法名字相关的参数：getter/setter
                默认情况下，@property生成的getter/setter方法名字都是最标准的名字，其实我们可以自定义getter/setter名字。
                getter：getter=xxx，getter的名字变成xxx
                setter：setter=zzz，setter的名字变成zzz，注意setter是有参数的要加冒号。
                注意：如果用getter和setter改变了名字，点语法依旧有效。（编译器也自动跟着转换）建议还是别改【无论什么情况都别生成setter方法的名字，默认情况生成的名字就是最标准的了】BOOL类型的属性在某些情况下可以改getter名字来增加阅读性。
 
 12 @class
    当两个类相互引用相互包含的时候，会陷入循环引用 -> 无限递归，无法编译通过。
    解决方案：不要用import "Book.h"，用@class Book
            其中一边不要用#import引入对方的头文件，而使用@class 类名，来标注这是一个类，这样可以在不引用对方头文件的情况下，告诉编译器是一个类。
    @class和#import的区别：
        a #import是将头文件的内容拷贝到写指令的地方
        b @class不会拷贝任何内容，只是告诉编译器这是一个类。
        c 在m文件中再#import头文件就可以使用了（不引用只是不会提示该方法，但也是可以使用的）
 
 13 循环retain
    当两个对象相互引用的时候：
        a对象的属性是b对象，b对象的属性是a对象，如果两边都使用retain，就会发生内存泄漏。
        解决方法：只有一边用retain，另一边用assign。
    
 */

#import <Foundation/Foundation.h>

int main(int argc, const char * argv[]) {
    
    return 0;
}
