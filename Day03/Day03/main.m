/*
 DAY2 复习
 1. 对象在内存中的存储
    Person *p1 = [Person new];
 2. nil和NULL
    a. 只能作为指针变量的值，代表不指向任何空间
 3. 多个指针指向同一个对象 / 4. 分组导航标记 / 5. 方法与函数 / 6. 犯错列表 / 7. 对象与方法
 ...
 
 DAY3
 -----------------------
 在一个target中不能访问另一个target的类
 -----------------------
 1. 异常处理
    a. 我们写的源代码不符合语法规范，然后编译报错 -> 程序无法编译
    b. bug：程序可编译，可链接，可执行，但程序执行结果不符合预期 -> 通过调试寻找发生bug的原因
    c. 异常：程序可以编译，可链接，可执行，当程序执行的时候，处于某种特定条件下，程序的执行就会终止 -> 程序会立即中止运行，并且后面的代码不会执行 （ios程序闪退）
    d. 处理异常：为了让程序在执行的时候发生义仓你不会崩溃，而是继续执行
          语法：
            @try
            {
            }
            @catch(NSException *ex)
            {
                (%@打印指针指向的对象）
                NSLog(@"%@", ex);
            }
            @finally
            {
            }
            将可能发生异常的代码放在try中，如果发生异常，不会崩溃而是立刻跳转到catch中执行里面的代码。
            finally块中的代码，无论try中是否发生了异常，finally都会执行
    e. try catch不是万能的，不是所有的运行时错误都能处理。C语言的异常是无法处理的，在实际开发中用的相对较少。避免异常最常用的方式还是用if判断
 
 2. oc中的方法分为两类：
    1）对象方法/实例方法：想调用方法，就得创建对象
        -> 声明： - (void) sayhi;
    2）类方法：调用不依赖对象，如果要调用类方法，不需要创建对象，直接通过类名来调用
        -> 声明： + (void) sayhi;
           调用：[类名 类方法名]

 3. 分析类方法调用的
    类方法的特点：
    1. 节约空间：因为调用类方法不用创建对象，这样节约空间
    2. 提高效率：因为调用类方法不需要拐弯，直接找到类，直接执行类中的方法
    3. 但是类方法无法直接访问内部属性。
        因为属性是在对象创造的时候，跟随对象一起创建在对象中
        类第一次被访问的时候，会做类加载，是把类的代码存储在代码段
    因为属性只有在对象创建的时候才会被创建在对象之中，而类方法在执行的时候可能还没有对象，虽然不能直接访问属性，但是我们可以在类方法中创建一个对象去访问这个对象的属性。
    4. 在类方法中不能通过self字节调用当前类的其他的对象方法，因为对象方法只能通过对象来调用，而这个时候没有对象。
    5. 在对象方法中可以直接调用类方法。
    6. 什么时候可以将方法l定义为类方法：
        a 如果方法不需要直接访问属性，也不需要直接调用其他的对象方法，那么可以直接将方法定义为类方法，这样可以节约空间，提高效率
        b 类方法的规范：如果我们写一个类，那要求提供一个和类名同名的类方法，这个方法创建一个最纯洁的类的实现。（constructor）苹果和第三方写的类都遵守这个规范。
        c 如果希望创建的对象由调用者制定，就为这个类方法带参数：类名WithXXX。。。（苹果都遵守这个规范）
    
 4. NSString：
    1. NSString是以恶数据类型，用来保存oc字符串的
    2. 但其实NSString也是一个类，是Foundation框架中的一个类，用来存储oc字符串的。
    3. 其实完整的标准的创建NSString对象的方式 NSString *str = [NSString string];
       这种方式创建的字符串是空字符串@“”
       但是NSString是我们最常用的一个对象，所以oc使用了一种更为简单的方式创建字符串对象，直接使用@来表示一个oc字符串。
       @“Lexi”本质是一个NSString对象，str的值是这个对象的地址
       %p 打印的是指针变量的值
       %@ 打印的是指针变量指向的对象
    4. 最常用的对象方法
        a length方法：返回值为NSUInteger, 其实就是unsigned long，得到字符串的个数，可以处理中文
        b 得到字符串指定下标的字符：characterAtIndex (返回unichar）返回unichar不反回char的原因是unichar占用2个字符，可以放得下中文，如果要输出unichar的值要用%C （char用%c）
        c 判断两个字符串的内容是否相同
            判断两个字符串的内容是否相同，不要用==去判断，要用isEqualToString
    5. 比较两个字符串的大小 （比ascii码）返回NSComparisonResult (完全可以用int类来接受结果，因为返回值是一个枚举：-1小，0相等，1大于）
 
 5. 匿名对象
    1. 之前创建对象的做法：
        Person *p1 = [Person new];
       让一个指针指向一个对象，这个指针就叫做这个对象的名字
    2. 匿名对象：
        没有名字的对象，如果我们创建一个对象，没有用一个指针存储这个对象的地址，也就是没有任何指针指向这个对象，那么这个对象就叫做匿名对象。
        [Person new]
    3. 如何去使用一个匿名对象：
        [Person new]->_name = @"jack";
        [[Person new] sayHi];
        [Person new]这句代码结果世纪就是创建的对象的指针，那么就可以直接被使用
    4. 注意点：
        a 匿名对象只能使用一次
        b 每次创建匿名对象都是不同的对象
    5. 有什么用？
        a 如果某个对象的成员只会被用一次，用完之后再也不需要，那么可以用匿名对象
        b 如果方法的参数是一个对象，而调用者为这个参数赋值的对象，就是专门来给这个方法传递的并且这个对象调用者不会使用，那么这个时候就可以直接微方法传递一个匿名对象
 
  6. 面向对象的三大特征
        a 封装
            函数就是一个封装的体现。
            类，是更高级别的封装。类将数据和行为封装为了一个整体。
            *好处 -> 屏蔽内部实现，外界不需要知道内部如何实现，只需要知道这个对象有什么用
                 -> 方便操作。
                 -> 后期维护十分便利。
        b 继承
        c 多态
 
 7. setter的封装：
        在为对象的属性赋值的时候，希望对数据做一个逻辑验证，如果在值不在属性范围内就做默认处理。
        不能写@public了，一旦写上public，就意味着外界可以直接访问对象 -> 任意为属性赋值了。
        要为类提供一个方法，这个方法专门给属性赋值，这个方法一定是对象方法，为对象赋值，这个方法没有返回值。
        方法的名字必须叫set属性。方法一定有参数，参数类型和属性类型一致，参数名称和属性名称一致

 8. getter的封装：
        提供一个对象方法，做的事就是取属性的值，名称就叫属性名称（去掉下划线），没有参数。

 9. 什么时候需要为属性封装setter和getter？
        a 只要属性需要被外界访问，就要为这个属性封装setter和getter，哪怕在赋值的时候不需要任何逻辑验证。（oc规范）
        b 如果属性只在类的内部访问，那么就不需要为其封装getter和setter
 10. 只读封装和只写封装：
        a 只读封装：只提供getter不提供setter
        b 只写封装：只提供setter不提供getter
 
 11. 对象与对象之间的关系：
        a 组合关系： 一个计算机由cpu，内存，主板，显卡，声卡，网卡。。。组成，计算机和cpu的关系叫组合关系
        b 依赖关系：一个对象的方法的参数是另外一个对象，那么他们的关系是依赖关系。人打电话，人类依赖于电话类。
        c 关联关系：关联体现在两个类之间语义级别有强关联关系。简单来说：一个类作为另一个类的属性，但他们不是组合关系，是拥有关系（人拥有狗）
        d 继承关系
 
        耦合度：当修改一个对象的时候，对另一个对象的影响程度。（当两个类具有依赖关系）
        低耦合：当修改一个对象的时候，对另一个对象影响较小甚至没有影响。
        高内聚：一个对象仅仅做自己相关的事情。
        单一职责原则：一个类只做自己的事情，别人的事情别人做。
 
 */

#import <Foundation/Foundation.h>

int main(int argc, const char * argv[]) {
    NSString *str1 = @"Lexi";
    NSString *str2 = @"莱克斯";
    NSUInteger lengthOfStr = [str1 length];
    NSLog(@"Length of %@ is %lu", str1, (unsigned long)lengthOfStr);
    
    unichar ch = [str2 characterAtIndex:1];
    NSLog(@"2nd character of %@ is %C", str2, ch);
    
    BOOL isEqual = [str1 isEqualToString:str2];
    NSLog(@"%@ is equal to %@?: %hhd", str1, str2, isEqual);
    
    NSComparisonResult res = [str1 compare:str2];
    NSLog(@"%ld", (long)res);
    
    return 0;
}
